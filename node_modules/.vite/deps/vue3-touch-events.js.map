{
  "version": 3,
  "sources": ["../../vue3-touch-events/dist/index.js"],
  "sourcesContent": ["/**\n * @project   vue3-touch-events\n * @author    Robin Rodricks, Xavier Julien, Jerry Bendy\n * @since     30/4/2021\n * @url       https://github.com/robinrodricks/vue3-touch-events\n */\n// Helper function to get X coordinate from touch/mouse event\nfunction touchX(event) {\n    var _a, _b, _c;\n    if (event.type.indexOf('mouse') !== -1) {\n        return event.clientX;\n    }\n    return (_c = (_b = (_a = event.touches) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.clientX) !== null && _c !== void 0 ? _c : 0;\n}\n// Helper function to get Y coordinate from touch/mouse event\nfunction touchY(event) {\n    var _a, _b, _c;\n    if (event.type.indexOf('mouse') !== -1) {\n        return event.clientY;\n    }\n    return (_c = (_b = (_a = event.touches) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.clientY) !== null && _c !== void 0 ? _c : 0;\n}\n// Check for passive event listener support\nconst isPassiveSupported = (function () {\n    let supportsPassive = false;\n    try {\n        const opts = Object.defineProperty({}, 'passive', {\n            get: function () {\n                supportsPassive = true;\n                return true;\n            }\n        });\n        window.addEventListener('test', null, opts);\n    }\n    catch (e) { }\n    return supportsPassive;\n})();\n// Main Vue Touch Events plugin\nconst Vue3TouchEvents = {\n    install(app, constructorOptions) {\n        // Default global options merged with constructor options\n        var globalOptions = Object.assign({}, {\n            // CORE\n            touchClass: '',\n            namespace: 'touch',\n            // CLICK/TAP\n            disableClick: false,\n            tapTolerance: 10, // px\n            touchHoldTolerance: 400, // ms\n            longTapTimeInterval: 400, // ms\n            rollOverFrequency: 100, // ms\n            // DRAG\n            dragFrequency: 10, // ms\n            dragOutside: false,\n            // SWIPE\n            swipeTolerance: 100, // px\n            swipeConeSize: 0.75, // number between 0 to 1\n            // ZOOM\n            zoomFrequency: 10, // ms\n            zoomDistance: 10, // px\n            zoomInOutDistance: 100, // px\n            // NOTE: When adding props here, update `index.d.ts` as well!!\n        }, constructorOptions);\n        /** Fired when the user performs a MOUSE DOWN on the object */\n        function touchStartEvent(event) {\n            var $this = this.$$touchObj, isTouchEvent = event.type.indexOf('touch') >= 0, isMouseEvent = event.type.indexOf('mouse') >= 0, $el = this;\n            if (isTouchEvent) {\n                $this.lastTouchStartTime = event.timeStamp;\n            }\n            if (isMouseEvent && $this.lastTouchStartTime && event.timeStamp - $this.lastTouchStartTime < 350) {\n                return;\n            }\n            if ($this.touchStarted) {\n                return;\n            }\n            addTouchClass(this);\n            $this.touchStarted = true; // always true while the element is being PRESSED\n            $this.touchMoved = false; // true only when the element is PRESSED and DRAGGED a bit\n            $this.swipeOutBounded = false;\n            $this.isZooming = false;\n            $this.startX = touchX(event);\n            $this.startY = touchY(event);\n            $this.currentX = 0; // always updated with the last mouse X/Y while over the element\n            $this.currentY = 0;\n            $this.touchStartTime = event.timeStamp;\n            // performance: only process swipe events if `swipe.*` event is registered on this element\n            $this.hasSwipe = hasEvent($this, 'swipe')\n                || hasEvent($this, 'swipe.left') || hasEvent($this, 'swipe.right')\n                || hasEvent($this, 'swipe.top') || hasEvent($this, 'swipe.bottom');\n            // performance: only process zoom events if `zoom.*` event is registered on this element\n            $this.hasZoom = hasEvent($this, 'zoom') || hasEvent($this, 'zoom.in') || hasEvent($this, 'zoom.out');\n            // performance: only start hold timer if the `hold` event is registered on this element\n            if (hasEvent($this, 'hold')) {\n                // Trigger touchhold event after `touchHoldTolerance` MS\n                $this.touchHoldTimer = setTimeout(function () {\n                    $this.touchHoldTimer = null;\n                    triggerEvent(event, $el, 'hold');\n                }, $this.options.touchHoldTolerance);\n            }\n            triggerEvent(event, this, 'press');\n        }\n        /**\n        Fired when the user MOVES the mouse over the window.\n        */\n        function touchMoveEventWindow(event) {\n            // only process if pressed\n            var $this = this.$$touchObj;\n            if ($this.touchStarted == true) {\n                // process event and pass 'this' onward\n                touchMoveEvent(event, $this, false);\n            }\n            else {\n                // TODO: mobile support\n                // if rollover events are wanted and this is a mouse event\n                if (hasEvent($this, 'rollover') && event.clientX != null) {\n                    var mouseEvent = event;\n                    // if the mouse is actually over this object (within this obj's bounds)\n                    const rect = $this.element.getBoundingClientRect();\n                    if (mouseEvent.clientX >= rect.left && mouseEvent.clientX <= rect.right &&\n                        mouseEvent.clientY >= rect.top && mouseEvent.clientY <= rect.bottom) {\n                        // process rollovers only and pass 'this' onward\n                        touchMoveEvent(event, $this, true);\n                    }\n                }\n            }\n        }\n        /**\n        Fired when the user DRAGS the object or MOVES the mouse over the object.\n        */\n        function touchMoveEvent(event, $this = null, onlyProcessRollover = false) {\n            if ($this == null)\n                $this = this.$$touchObj;\n            var curX = touchX(event);\n            var curY = touchY(event);\n            var movedAgain = ($this.currentX != curX) || ($this.currentY != curY);\n            $this.currentX = curX;\n            $this.currentY = curY;\n            // dont process if only rollover wanted!\n            if (!onlyProcessRollover) {\n                //--------------------------------------------------------------------------------------\n                //\t\t\t\t\t\t\t\t\tDRAG ONCE\n                //--------------------------------------------------------------------------------------\n                if (!$this.touchMoved) {\n                    var tapTolerance = $this.options.tapTolerance;\n                    $this.touchMoved = Math.abs($this.startX - $this.currentX) > tapTolerance ||\n                        Math.abs($this.startY - $this.currentY) > tapTolerance;\n                    // trigger `drag.once` only once after mouse FIRST moved while dragging the element\n                    // (`touchMoved` is the flag that indicates we no longer need to trigger this)\n                    if ($this.touchMoved) {\n                        cancelTouchHoldTimer($this);\n                        triggerEvent(event, $this.element, 'drag.once');\n                    }\n                }\n                //--------------------------------------------------------------------------------------\n                //\t\t\t\t\t\t\t\t\t\tSWIPE\n                //--------------------------------------------------------------------------------------\n                // performance: only process swipe events if `swipe.*` event is registered on this element\n                else if ($this.hasSwipe && !$this.swipeOutBounded) {\n                    var swipeOutBounded = $this.options.swipeTolerance;\n                    // Process swipe events using cones\n                    if (Math.abs($this.startX - $this.currentX) / Math.abs($this.startY - $this.currentY) > $this.options.swipeConeSize &&\n                        Math.abs($this.startY - $this.currentY) / Math.abs($this.startX - $this.currentX) > $this.options.swipeConeSize) {\n                        $this.swipeOutBounded = (Math.abs($this.startY - $this.currentY) < swipeOutBounded) && (Math.abs($this.startX - $this.currentX) < swipeOutBounded);\n                    }\n                }\n            }\n            //--------------------------------------------------------------------------------------\n            //\t\t\t\t\t\t\t\t\tROLL OVER\n            //--------------------------------------------------------------------------------------\n            // only trigger `rollover` event if cursor actually moved over this element\n            if (movedAgain && hasEvent($this, 'rollover')) {\n                // throttle the `rollover` event based on `rollOverFrequency`\n                var now = event.timeStamp;\n                if ($this.touchRollTime == null || now > ($this.touchRollTime + $this.options.rollOverFrequency)) {\n                    $this.touchRollTime = now;\n                    triggerEvent(event, $this.element, 'rollover');\n                }\n            }\n            // exit if only rollovers wanted!\n            if (onlyProcessRollover) {\n                return;\n            }\n            //--------------------------------------------------------------------------------------\n            //\t\t\t\t\t\t\t\t\t\tDRAG\n            //--------------------------------------------------------------------------------------\n            // only trigger `drag` event if cursor actually moved and if we are still dragging this element\n            if ($this.touchStarted && $this.touchMoved && movedAgain && hasEvent($this, 'drag')) {\n                // throttle the `drag` event based on `dragFrequency`\n                var now = event.timeStamp;\n                if ($this.touchDragTime == null || now > ($this.touchDragTime + $this.options.dragFrequency)) {\n                    $this.touchDragTime = now;\n                    triggerEvent(event, $this.element, 'drag');\n                }\n            }\n            //--------------------------------------------------------------------------------------\n            //\t\t\t\t\t\t\t\t\t\tZOOM\n            //--------------------------------------------------------------------------------------\n            // only trigger `zoom` event if cursor actually moved\n            if ($this.touchStarted && $this.hasZoom) {\n                // throttle the `zoom` event based on `zoomFrequency`\n                var now = event.timeStamp;\n                if ($this.touchZoomTime == null || now > ($this.touchZoomTime + $this.options.zoomFrequency)) {\n                    $this.touchZoomTime = now;\n                    checkZoom($this, event);\n                }\n            }\n        }\n        function checkZoom($this, event) {\n            // get the list of changed touches from the event\n            const touches = event.changedTouches;\n            // check if exactly two fingers are being used\n            if (touches.length !== 2) {\n                // reset dragging state if fewer or more than 2 touches are detected\n                $this.isZooming = false;\n                return;\n            }\n            // calculate the distance between the two touch points (euclidean distance)\n            const newDistance = Math.sqrt(Math.pow(touches[0].clientX - touches[1].clientX, 2) + // horizontal distance\n                Math.pow(touches[0].clientY - touches[1].clientY, 2) // vertical distance\n            );\n            // initialize the gesture if it's not already active\n            if (!$this.isZooming) {\n                // mark the gesture as active and store the initial distance\n                $this.isZooming = true;\n                $this.initialZoomDistance = newDistance;\n                return;\n            }\n            // calculate the zoom factor based on the change in distance\n            const zoomFactor = newDistance / $this.initialZoomDistance;\n            //--------------------------------------------------------------------------------------\n            //\t\t\t\t\t\t\t\t\t\tZOOM\n            //--------------------------------------------------------------------------------------\n            if (hasEvent($this, 'zoom')) {\n                // check if the zoom factor exceeds the threshold for zooming\n                if (Math.abs(zoomFactor - 1) > ($this.options.zoomDistance / $this.initialZoomDistance)) {\n                    // trigger the zoom callback with the source and zoom factor\n                    triggerEvent(event, $this.element, 'zoom', zoomFactor);\n                }\n            }\n            //--------------------------------------------------------------------------------------\n            //\t\t\t\t\t\t\t\t\tZOOM IN/OUT\n            //--------------------------------------------------------------------------------------\n            if (hasEvent($this, 'zoom.in') || hasEvent($this, 'zoom.out')) {\n                // check if the distance change is significant enough to count as a zoom gesture\n                if (Math.abs(newDistance - $this.initialZoomDistance) > $this.options.zoomInOutDistance) {\n                    // determine zoom direction\n                    if (newDistance > $this.initialZoomDistance) {\n                        // fingers moved apart = zoom in\n                        triggerEvent(event, $this.element, 'zoom.in');\n                    }\n                    else {\n                        // fingers moved closer = zoom out\n                        triggerEvent(event, $this.element, 'zoom.out');\n                    }\n                }\n            }\n            // reset the dragging state after detecting the pinch gesture\n            $this.isZooming = false;\n        }\n        function touchCancelEvent() {\n            var $this = this.$$touchObj;\n            if ($this.touchStarted == true) {\n                cancelTouchHoldTimer($this);\n                removeTouchClass(this);\n                $this.touchStarted = $this.touchMoved = false;\n                $this.startX = $this.startY = 0;\n            }\n        }\n        /** Fired when the user performs a MOUSE UP on the object (releases the mouse button or finger press) */\n        function touchEndEvent(event) {\n            var $this = this.$$touchObj;\n            if ($this.touchStarted == true) {\n                var isTouchEvent = event.type.indexOf('touch') >= 0;\n                var isMouseEvent = event.type.indexOf('mouse') >= 0;\n                if (isTouchEvent) {\n                    $this.lastTouchEndTime = event.timeStamp;\n                }\n                var touchholdEnd = isTouchEvent && !$this.touchHoldTimer;\n                cancelTouchHoldTimer($this);\n                $this.touchStarted = false;\n                removeTouchClass(this);\n                if (isMouseEvent && $this.lastTouchEndTime && event.timeStamp - $this.lastTouchEndTime < 350) {\n                    return;\n                }\n                //--------------------------------------------------------------------------------------\n                //\t\t\t\t\t\t\t\t\tRELEASE\n                //--------------------------------------------------------------------------------------\n                // trigger `end` event when touch stopped\n                triggerEvent(event, this, 'release');\n                //--------------------------------------------------------------------------------------\n                //\t\t\t\t\t\t\t\tLONGTAP / HOLD / TAP\n                //--------------------------------------------------------------------------------------\n                if (!$this.touchMoved) {\n                    // detect if this is a longTap event or not\n                    if (hasEvent($this, 'longtap') && event.timeStamp - $this.touchStartTime > $this.options.longTapTimeInterval) {\n                        if (event.cancelable) {\n                            event.preventDefault();\n                        }\n                        triggerEvent(event, this, 'longtap');\n                    }\n                    else if (hasEvent($this, 'hold') && touchholdEnd) {\n                        if (event.cancelable) {\n                            event.preventDefault();\n                        }\n                        return;\n                    }\n                    else {\n                        // emit tap event\n                        triggerEvent(event, this, 'tap');\n                    }\n                }\n                //--------------------------------------------------------------------------------------\n                //\t\t\t\t\t\t\t\t\tSWIPE\n                //--------------------------------------------------------------------------------------\n                // only process swipe events if `swipe.*` event is registered on this element\n                else if ($this.hasSwipe && !$this.swipeOutBounded) {\n                    var swipeOutBounded = $this.options.swipeTolerance, direction, distanceY = Math.abs($this.startY - $this.currentY), distanceX = Math.abs($this.startX - $this.currentX);\n                    if (distanceY > swipeOutBounded || distanceX > swipeOutBounded) {\n                        // Check which swipe direction it is based on the mouse movement\n                        if (distanceX > swipeOutBounded) {\n                            direction = $this.startX > $this.currentX ? 'left' : 'right';\n                        }\n                        else {\n                            direction = $this.startY > $this.currentY ? 'top' : 'bottom';\n                        }\n                        // Only emit the specified event when it has modifiers\n                        if (hasEvent($this, 'swipe.' + direction)) {\n                            triggerEvent(event, this, 'swipe.' + direction, direction);\n                        }\n                        else {\n                            // Emit a common event when it has no any modifier\n                            triggerEvent(event, this, 'swipe', direction);\n                        }\n                    }\n                }\n            }\n        }\n        function mouseEnterEvent() {\n            addTouchClass(this);\n        }\n        function mouseLeaveEvent() {\n            removeTouchClass(this);\n        }\n        function hasEvent($this, eventType) {\n            var callbacks = $this.callbacks[eventType];\n            return (callbacks != null && callbacks.length > 0);\n        }\n        function triggerEvent(e, $el, eventType, param) {\n            var $this = $el.$$touchObj;\n            // get the subscribers for this event\n            var callbacks = $this.callbacks[eventType];\n            // exit if no subscribers to this particular event\n            if (callbacks == null || callbacks.length === 0) {\n                return null;\n            }\n            // per callback\n            for (var i = 0; i < callbacks.length; i++) {\n                var binding = callbacks[i];\n                if (binding.modifiers.stop) {\n                    e.stopPropagation();\n                }\n                if (binding.modifiers.prevent) {\n                    e.preventDefault();\n                }\n                // handle `self` modifier`\n                if (binding.modifiers.self && e.target !== e.currentTarget) {\n                    continue;\n                }\n                if (typeof binding.value === 'function') {\n                    if (param) {\n                        binding.value(param, e);\n                    }\n                    else {\n                        binding.value(e);\n                    }\n                }\n            }\n        }\n        function addTouchClass($el) {\n            var className = $el.$$touchObj.options.touchClass;\n            className && $el.classList.add(className);\n        }\n        function removeTouchClass($el) {\n            var className = $el.$$touchObj.options.touchClass;\n            className && $el.classList.remove(className);\n        }\n        function cancelTouchHoldTimer($this) {\n            if ($this && $this.touchHoldTimer) {\n                clearTimeout($this.touchHoldTimer);\n                $this.touchHoldTimer = null;\n            }\n        }\n        function buildTouchObj($el, extraOptions) {\n            var touchObj = $el.$$touchObj || {\n                element: $el,\n                // an object contains all callbacks registered,\n                // key is event name, value is an array\n                callbacks: {},\n                // prevent bind twice, set to true when event bound\n                hasBindTouchEvents: false,\n                // default options, would be override by v-touch-options\n                options: globalOptions,\n                events: {},\n            };\n            if (extraOptions) {\n                touchObj.options = Object.assign({}, touchObj.options, extraOptions);\n            }\n            $el.$$touchObj = touchObj;\n            return $el.$$touchObj;\n        }\n        function addEvents(events) {\n            for (const eventName in events) {\n                if (events.hasOwnProperty(eventName)) {\n                    const [target, handler] = events[eventName];\n                    target.addEventListener(eventName, handler);\n                }\n            }\n        }\n        function removeEvents(events) {\n            for (const eventName in events) {\n                if (events.hasOwnProperty(eventName)) {\n                    const [target, handler] = events[eventName];\n                    target.removeEventListener(eventName, handler);\n                }\n            }\n        }\n        app.directive(globalOptions.namespace, {\n            beforeMount: function ($el, binding) {\n                // build a touch configuration object\n                var $this = buildTouchObj($el);\n                // declare passive option for the event listener. Defaults to { passive: true } if supported\n                var passiveOpt = isPassiveSupported ? { passive: true } : false;\n                // register callback\n                var eventType = binding.arg || 'tap';\n                switch (eventType) {\n                    case 'swipe':\n                        var _m = binding.modifiers;\n                        if (_m.left || _m.right || _m.top || _m.bottom) {\n                            for (var i in binding.modifiers) {\n                                if (['left', 'right', 'top', 'bottom'].indexOf(i) >= 0) {\n                                    var _e = 'swipe.' + i;\n                                    $this.callbacks[_e] = $this.callbacks[_e] || [];\n                                    $this.callbacks[_e].push(binding);\n                                }\n                            }\n                        }\n                        else {\n                            $this.callbacks.swipe = $this.callbacks.swipe || [];\n                            $this.callbacks.swipe.push(binding);\n                        }\n                        break;\n                    case 'press':\n                    case 'drag':\n                        if (binding.modifiers.disablePassive) {\n                            // change the passive option for the `drag` event if disablePassive modifier exists\n                            passiveOpt = false;\n                        }\n                    default:\n                        $this.callbacks[eventType] = $this.callbacks[eventType] || [];\n                        $this.callbacks[eventType].push(binding);\n                }\n                // prevent bind twice\n                if ($this.hasBindTouchEvents) {\n                    return;\n                }\n                // ADD MOBILE EVENTS\n                if ($this.options.dragOutside) {\n                    $this.events['touchstart'] = [$el, touchStartEvent];\n                    $this.events['touchmove'] = [window, touchMoveEventWindow.bind($el)];\n                    $this.events['touchcancel'] = [window, touchCancelEvent.bind($el)];\n                    $this.events['touchend'] = [window, touchEndEvent.bind($el)];\n                }\n                else {\n                    $this.events['touchstart'] = [$el, touchStartEvent];\n                    $this.events['touchmove'] = [$el, touchMoveEventWindow];\n                    $this.events['touchcancel'] = [$el, touchCancelEvent];\n                    $this.events['touchend'] = [$el, touchEndEvent];\n                }\n                // ADD DESKTOP EVENTS\n                if (!$this.options.disableClick) {\n                    if ($this.options.dragOutside) {\n                        $this.events['mousedown'] = [$el, touchStartEvent];\n                        $this.events['mousemove'] = [window, touchMoveEventWindow.bind($el)];\n                        $this.events['mouseup'] = [window, touchEndEvent.bind($el)];\n                        $this.events['mouseenter'] = [$el, mouseEnterEvent];\n                        $this.events['mouseleave'] = [$el, mouseLeaveEvent];\n                    }\n                    else {\n                        $this.events['mousedown'] = [$el, touchStartEvent];\n                        $this.events['mousemove'] = [$el, touchMoveEvent];\n                        $this.events['mouseup'] = [$el, touchEndEvent];\n                        $this.events['mouseenter'] = [$el, mouseEnterEvent];\n                        $this.events['mouseleave'] = [$el, mouseLeaveEvent];\n                    }\n                }\n                // register all events\n                addEvents($this.events);\n                // set bind mark to true\n                $this.hasBindTouchEvents = true;\n            },\n            unmounted: function ($el) {\n                var touchObj = $el.$$touchObj;\n                cancelTouchHoldTimer(touchObj);\n                // unregister all events\n                if (touchObj && touchObj.events) {\n                    removeEvents(touchObj.events);\n                    touchObj.events = {};\n                }\n                // remove vars\n                delete $el.$$touchObj;\n            }\n        });\n        // Register additional directives for class\n        app.directive(`${globalOptions.namespace}-class`, {\n            beforeMount: function ($el, binding) {\n                buildTouchObj($el, {\n                    touchClass: binding.value\n                });\n            }\n        });\n        // Register additional directives for options\n        app.directive(`${globalOptions.namespace}-options`, {\n            beforeMount: function ($el, binding) {\n                buildTouchObj($el, binding.value);\n            }\n        });\n    }\n};\n/*\n * Exports\n */\nexport default Vue3TouchEvents;\n"],
  "mappings": "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",
  "names": []
}
