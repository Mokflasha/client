import "./chunk-BUSYA2B4.js";

// node_modules/vue3-touch-events/dist/index.js
function touchX(event) {
  var _a, _b, _c;
  if (event.type.indexOf("mouse") !== -1) {
    return event.clientX;
  }
  return (_c = (_b = (_a = event.touches) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.clientX) !== null && _c !== void 0 ? _c : 0;
}
function touchY(event) {
  var _a, _b, _c;
  if (event.type.indexOf("mouse") !== -1) {
    return event.clientY;
  }
  return (_c = (_b = (_a = event.touches) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.clientY) !== null && _c !== void 0 ? _c : 0;
}
var isPassiveSupported = function() {
  let supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get: function() {
        supportsPassive = true;
        return true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {
  }
  return supportsPassive;
}();
var Vue3TouchEvents = {
  install(app, constructorOptions) {
    var globalOptions = Object.assign({}, {
      // CORE
      touchClass: "",
      namespace: "touch",
      // CLICK/TAP
      disableClick: false,
      tapTolerance: 10,
      // px
      touchHoldTolerance: 400,
      // ms
      longTapTimeInterval: 400,
      // ms
      rollOverFrequency: 100,
      // ms
      // DRAG
      dragFrequency: 10,
      // ms
      dragOutside: false,
      // SWIPE
      swipeTolerance: 100,
      // px
      swipeConeSize: 0.75,
      // number between 0 to 1
      // ZOOM
      zoomFrequency: 10,
      // ms
      zoomDistance: 10,
      // px
      zoomInOutDistance: 100
      // px
      // NOTE: When adding props here, update `index.d.ts` as well!!
    }, constructorOptions);
    function touchStartEvent(event) {
      var $this = this.$$touchObj, isTouchEvent = event.type.indexOf("touch") >= 0, isMouseEvent = event.type.indexOf("mouse") >= 0, $el = this;
      if (isTouchEvent) {
        $this.lastTouchStartTime = event.timeStamp;
      }
      if (isMouseEvent && $this.lastTouchStartTime && event.timeStamp - $this.lastTouchStartTime < 350) {
        return;
      }
      if ($this.touchStarted) {
        return;
      }
      addTouchClass(this);
      $this.touchStarted = true;
      $this.touchMoved = false;
      $this.swipeOutBounded = false;
      $this.isZooming = false;
      $this.startX = touchX(event);
      $this.startY = touchY(event);
      $this.currentX = 0;
      $this.currentY = 0;
      $this.touchStartTime = event.timeStamp;
      $this.hasSwipe = hasEvent($this, "swipe") || hasEvent($this, "swipe.left") || hasEvent($this, "swipe.right") || hasEvent($this, "swipe.top") || hasEvent($this, "swipe.bottom");
      $this.hasZoom = hasEvent($this, "zoom") || hasEvent($this, "zoom.in") || hasEvent($this, "zoom.out");
      if (hasEvent($this, "hold")) {
        $this.touchHoldTimer = setTimeout(function() {
          $this.touchHoldTimer = null;
          triggerEvent(event, $el, "hold");
        }, $this.options.touchHoldTolerance);
      }
      triggerEvent(event, this, "press");
    }
    function touchMoveEventWindow(event) {
      var $this = this.$$touchObj;
      if ($this.touchStarted == true) {
        touchMoveEvent(event, $this, false);
      } else {
        if (hasEvent($this, "rollover") && event.clientX != null) {
          var mouseEvent = event;
          const rect = $this.element.getBoundingClientRect();
          if (mouseEvent.clientX >= rect.left && mouseEvent.clientX <= rect.right && mouseEvent.clientY >= rect.top && mouseEvent.clientY <= rect.bottom) {
            touchMoveEvent(event, $this, true);
          }
        }
      }
    }
    function touchMoveEvent(event, $this = null, onlyProcessRollover = false) {
      if ($this == null)
        $this = this.$$touchObj;
      var curX = touchX(event);
      var curY = touchY(event);
      var movedAgain = $this.currentX != curX || $this.currentY != curY;
      $this.currentX = curX;
      $this.currentY = curY;
      if (!onlyProcessRollover) {
        if (!$this.touchMoved) {
          var tapTolerance = $this.options.tapTolerance;
          $this.touchMoved = Math.abs($this.startX - $this.currentX) > tapTolerance || Math.abs($this.startY - $this.currentY) > tapTolerance;
          if ($this.touchMoved) {
            cancelTouchHoldTimer($this);
            triggerEvent(event, $this.element, "drag.once");
          }
        } else if ($this.hasSwipe && !$this.swipeOutBounded) {
          var swipeOutBounded = $this.options.swipeTolerance;
          if (Math.abs($this.startX - $this.currentX) / Math.abs($this.startY - $this.currentY) > $this.options.swipeConeSize && Math.abs($this.startY - $this.currentY) / Math.abs($this.startX - $this.currentX) > $this.options.swipeConeSize) {
            $this.swipeOutBounded = Math.abs($this.startY - $this.currentY) < swipeOutBounded && Math.abs($this.startX - $this.currentX) < swipeOutBounded;
          }
        }
      }
      if (movedAgain && hasEvent($this, "rollover")) {
        var now = event.timeStamp;
        if ($this.touchRollTime == null || now > $this.touchRollTime + $this.options.rollOverFrequency) {
          $this.touchRollTime = now;
          triggerEvent(event, $this.element, "rollover");
        }
      }
      if (onlyProcessRollover) {
        return;
      }
      if ($this.touchStarted && $this.touchMoved && movedAgain && hasEvent($this, "drag")) {
        var now = event.timeStamp;
        if ($this.touchDragTime == null || now > $this.touchDragTime + $this.options.dragFrequency) {
          $this.touchDragTime = now;
          triggerEvent(event, $this.element, "drag");
        }
      }
      if ($this.touchStarted && $this.hasZoom) {
        var now = event.timeStamp;
        if ($this.touchZoomTime == null || now > $this.touchZoomTime + $this.options.zoomFrequency) {
          $this.touchZoomTime = now;
          checkZoom($this, event);
        }
      }
    }
    function checkZoom($this, event) {
      const touches = event.changedTouches;
      if (touches.length !== 2) {
        $this.isZooming = false;
        return;
      }
      const newDistance = Math.sqrt(
        Math.pow(touches[0].clientX - touches[1].clientX, 2) + // horizontal distance
        Math.pow(touches[0].clientY - touches[1].clientY, 2)
        // vertical distance
      );
      if (!$this.isZooming) {
        $this.isZooming = true;
        $this.initialZoomDistance = newDistance;
        return;
      }
      const zoomFactor = newDistance / $this.initialZoomDistance;
      if (hasEvent($this, "zoom")) {
        if (Math.abs(zoomFactor - 1) > $this.options.zoomDistance / $this.initialZoomDistance) {
          triggerEvent(event, $this.element, "zoom", zoomFactor);
        }
      }
      if (hasEvent($this, "zoom.in") || hasEvent($this, "zoom.out")) {
        if (Math.abs(newDistance - $this.initialZoomDistance) > $this.options.zoomInOutDistance) {
          if (newDistance > $this.initialZoomDistance) {
            triggerEvent(event, $this.element, "zoom.in");
          } else {
            triggerEvent(event, $this.element, "zoom.out");
          }
        }
      }
      $this.isZooming = false;
    }
    function touchCancelEvent() {
      var $this = this.$$touchObj;
      if ($this.touchStarted == true) {
        cancelTouchHoldTimer($this);
        removeTouchClass(this);
        $this.touchStarted = $this.touchMoved = false;
        $this.startX = $this.startY = 0;
      }
    }
    function touchEndEvent(event) {
      var $this = this.$$touchObj;
      if ($this.touchStarted == true) {
        var isTouchEvent = event.type.indexOf("touch") >= 0;
        var isMouseEvent = event.type.indexOf("mouse") >= 0;
        if (isTouchEvent) {
          $this.lastTouchEndTime = event.timeStamp;
        }
        var touchholdEnd = isTouchEvent && !$this.touchHoldTimer;
        cancelTouchHoldTimer($this);
        $this.touchStarted = false;
        removeTouchClass(this);
        if (isMouseEvent && $this.lastTouchEndTime && event.timeStamp - $this.lastTouchEndTime < 350) {
          return;
        }
        triggerEvent(event, this, "release");
        if (!$this.touchMoved) {
          if (hasEvent($this, "longtap") && event.timeStamp - $this.touchStartTime > $this.options.longTapTimeInterval) {
            if (event.cancelable) {
              event.preventDefault();
            }
            triggerEvent(event, this, "longtap");
          } else if (hasEvent($this, "hold") && touchholdEnd) {
            if (event.cancelable) {
              event.preventDefault();
            }
            return;
          } else {
            triggerEvent(event, this, "tap");
          }
        } else if ($this.hasSwipe && !$this.swipeOutBounded) {
          var swipeOutBounded = $this.options.swipeTolerance, direction, distanceY = Math.abs($this.startY - $this.currentY), distanceX = Math.abs($this.startX - $this.currentX);
          if (distanceY > swipeOutBounded || distanceX > swipeOutBounded) {
            if (distanceX > swipeOutBounded) {
              direction = $this.startX > $this.currentX ? "left" : "right";
            } else {
              direction = $this.startY > $this.currentY ? "top" : "bottom";
            }
            if (hasEvent($this, "swipe." + direction)) {
              triggerEvent(event, this, "swipe." + direction, direction);
            } else {
              triggerEvent(event, this, "swipe", direction);
            }
          }
        }
      }
    }
    function mouseEnterEvent() {
      addTouchClass(this);
    }
    function mouseLeaveEvent() {
      removeTouchClass(this);
    }
    function hasEvent($this, eventType) {
      var callbacks = $this.callbacks[eventType];
      return callbacks != null && callbacks.length > 0;
    }
    function triggerEvent(e, $el, eventType, param) {
      var $this = $el.$$touchObj;
      var callbacks = $this.callbacks[eventType];
      if (callbacks == null || callbacks.length === 0) {
        return null;
      }
      for (var i = 0; i < callbacks.length; i++) {
        var binding = callbacks[i];
        if (binding.modifiers.stop) {
          e.stopPropagation();
        }
        if (binding.modifiers.prevent) {
          e.preventDefault();
        }
        if (binding.modifiers.self && e.target !== e.currentTarget) {
          continue;
        }
        if (typeof binding.value === "function") {
          if (param) {
            binding.value(param, e);
          } else {
            binding.value(e);
          }
        }
      }
    }
    function addTouchClass($el) {
      var className = $el.$$touchObj.options.touchClass;
      className && $el.classList.add(className);
    }
    function removeTouchClass($el) {
      var className = $el.$$touchObj.options.touchClass;
      className && $el.classList.remove(className);
    }
    function cancelTouchHoldTimer($this) {
      if ($this && $this.touchHoldTimer) {
        clearTimeout($this.touchHoldTimer);
        $this.touchHoldTimer = null;
      }
    }
    function buildTouchObj($el, extraOptions) {
      var touchObj = $el.$$touchObj || {
        element: $el,
        // an object contains all callbacks registered,
        // key is event name, value is an array
        callbacks: {},
        // prevent bind twice, set to true when event bound
        hasBindTouchEvents: false,
        // default options, would be override by v-touch-options
        options: globalOptions,
        events: {}
      };
      if (extraOptions) {
        touchObj.options = Object.assign({}, touchObj.options, extraOptions);
      }
      $el.$$touchObj = touchObj;
      return $el.$$touchObj;
    }
    function addEvents(events) {
      for (const eventName in events) {
        if (events.hasOwnProperty(eventName)) {
          const [target, handler] = events[eventName];
          target.addEventListener(eventName, handler);
        }
      }
    }
    function removeEvents(events) {
      for (const eventName in events) {
        if (events.hasOwnProperty(eventName)) {
          const [target, handler] = events[eventName];
          target.removeEventListener(eventName, handler);
        }
      }
    }
    app.directive(globalOptions.namespace, {
      beforeMount: function($el, binding) {
        var $this = buildTouchObj($el);
        var passiveOpt = isPassiveSupported ? { passive: true } : false;
        var eventType = binding.arg || "tap";
        switch (eventType) {
          case "swipe":
            var _m = binding.modifiers;
            if (_m.left || _m.right || _m.top || _m.bottom) {
              for (var i in binding.modifiers) {
                if (["left", "right", "top", "bottom"].indexOf(i) >= 0) {
                  var _e = "swipe." + i;
                  $this.callbacks[_e] = $this.callbacks[_e] || [];
                  $this.callbacks[_e].push(binding);
                }
              }
            } else {
              $this.callbacks.swipe = $this.callbacks.swipe || [];
              $this.callbacks.swipe.push(binding);
            }
            break;
          case "press":
          case "drag":
            if (binding.modifiers.disablePassive) {
              passiveOpt = false;
            }
          default:
            $this.callbacks[eventType] = $this.callbacks[eventType] || [];
            $this.callbacks[eventType].push(binding);
        }
        if ($this.hasBindTouchEvents) {
          return;
        }
        if ($this.options.dragOutside) {
          $this.events["touchstart"] = [$el, touchStartEvent];
          $this.events["touchmove"] = [window, touchMoveEventWindow.bind($el)];
          $this.events["touchcancel"] = [window, touchCancelEvent.bind($el)];
          $this.events["touchend"] = [window, touchEndEvent.bind($el)];
        } else {
          $this.events["touchstart"] = [$el, touchStartEvent];
          $this.events["touchmove"] = [$el, touchMoveEventWindow];
          $this.events["touchcancel"] = [$el, touchCancelEvent];
          $this.events["touchend"] = [$el, touchEndEvent];
        }
        if (!$this.options.disableClick) {
          if ($this.options.dragOutside) {
            $this.events["mousedown"] = [$el, touchStartEvent];
            $this.events["mousemove"] = [window, touchMoveEventWindow.bind($el)];
            $this.events["mouseup"] = [window, touchEndEvent.bind($el)];
            $this.events["mouseenter"] = [$el, mouseEnterEvent];
            $this.events["mouseleave"] = [$el, mouseLeaveEvent];
          } else {
            $this.events["mousedown"] = [$el, touchStartEvent];
            $this.events["mousemove"] = [$el, touchMoveEvent];
            $this.events["mouseup"] = [$el, touchEndEvent];
            $this.events["mouseenter"] = [$el, mouseEnterEvent];
            $this.events["mouseleave"] = [$el, mouseLeaveEvent];
          }
        }
        addEvents($this.events);
        $this.hasBindTouchEvents = true;
      },
      unmounted: function($el) {
        var touchObj = $el.$$touchObj;
        cancelTouchHoldTimer(touchObj);
        if (touchObj && touchObj.events) {
          removeEvents(touchObj.events);
          touchObj.events = {};
        }
        delete $el.$$touchObj;
      }
    });
    app.directive(`${globalOptions.namespace}-class`, {
      beforeMount: function($el, binding) {
        buildTouchObj($el, {
          touchClass: binding.value
        });
      }
    });
    app.directive(`${globalOptions.namespace}-options`, {
      beforeMount: function($el, binding) {
        buildTouchObj($el, binding.value);
      }
    });
  }
};
var dist_default = Vue3TouchEvents;
export {
  dist_default as default
};
//# sourceMappingURL=vue3-touch-events.js.map
